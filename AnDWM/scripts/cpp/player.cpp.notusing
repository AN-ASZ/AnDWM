#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <cstdlib>
#include <cstdio>

// Run a shell command and get output
std::string runCommand(const std::string& cmd) {
    std::string result;
    char buffer[128];
    FILE* pipe = popen(cmd.c_str(), "r");
    if (!pipe) return "";
    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
        result += buffer;
    }
    pclose(pipe);
    if (!result.empty() && result.back() == '\n') result.pop_back();
    return result;
}

// Format artist: uppercase + remove " - TOPIC"
std::string formatArtist(const std::string& artist) {
    std::string res = artist;
    std::transform(res.begin(), res.end(), res.begin(), ::toupper);
    std::string suffix = " - TOPIC";
    if (res.size() >= suffix.size() &&
        res.compare(res.size() - suffix.size(), suffix.size(), suffix) == 0) {
        res.erase(res.size() - suffix.size());
    }
    return res;
}

// Split UTF-8 string into characters
std::vector<std::string> utf8ToChars(const std::string& str) {
    std::vector<std::string> chars;
    for (size_t i = 0; i < str.size();) {
        unsigned char c = str[i];
        size_t char_len = 1;
        if ((c & 0x80) == 0) char_len = 1;
        else if ((c & 0xE0) == 0xC0) char_len = 2;
        else if ((c & 0xF0) == 0xE0) char_len = 3;
        else if ((c & 0xF8) == 0xF0) char_len = 4;
        chars.push_back(str.substr(i, char_len));
        i += char_len;
    }
    return chars;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <app>\n";
        return 1;
    }
    std::string app = argv[1];

    // Colors
    std::string black = "#1E1D2D";
    std::string green2 = "#a6da95";
    std::string green3 = "#B8E9B4";
    std::string blue = "#96CDFB";

    // Get artist and title from playerctl
    std::string rawArtist = runCommand("playerctl -p " + app + " metadata --format '{{ artist }}'");
    std::string ARTIST = formatArtist(rawArtist);
    std::string TITLE = runCommand("playerctl -p " + app + " metadata --format '{{ title }}'");
    std::string TEXT = !ARTIST.empty() ? "  ["  + ARTIST + "]  " + TITLE : TITLE;

    int SCROLL_WIDTH = 30;
    const std::string STATE_FILE = "/dev/shm/scroll_pos.txt";

    // Load previous scroll index
    int i = 0;
    std::ifstream infile(STATE_FILE);
    if (infile.is_open()) { infile >> i; infile.close(); }

    // UTF-8 safe conversion
    std::vector<std::string> chars = utf8ToChars(TEXT);
    int TEXT_LEN = chars.size();
    if (i >= TEXT_LEN) i = 0;

    // Duplicate for wrapping
    std::vector<std::string> SCROLL_CHARS = chars;
    SCROLL_CHARS.insert(SCROLL_CHARS.end(), chars.begin(), chars.end());

    // Get playback position and length
    double pos = 0.0, len = 1.0;
    std::string posStr = runCommand("playerctl -p " + app + " position");
    std::string lenStr = runCommand("playerctl -p " + app + " metadata mpris:length");
    if (!posStr.empty()) pos = std::stod(posStr);
    if (!lenStr.empty()) len = std::stod(lenStr) / 1000000.0;

    int progress = static_cast<int>((pos / len) * SCROLL_WIDTH);

    // --- Slice with wrap-around ---
    std::string SLICE_BEFORE, SLICE_AFTER;
    for (int j = 0; j < progress; j++)
        SLICE_BEFORE += SCROLL_CHARS[(i + j) % SCROLL_CHARS.size()];
    for (int j = 0; j < SCROLL_WIDTH - progress; j++)
        SLICE_AFTER += SCROLL_CHARS[(i + progress + j) % SCROLL_CHARS.size()];

    // Print scrolling block
    std::cout << "^c" << black << "^ ^b" << green2 << "^ 󰎆 "
              << "^c" << black << "^" << SLICE_BEFORE
              << "^b" << green3 << "^" << SLICE_AFTER << " "
              << "^d^" << "^c" << blue << "^";

    // Update scroll index
    i = (i + 1) % TEXT_LEN;
    std::ofstream outfile(STATE_FILE);
    outfile << i << "\n";
    outfile.close();

    return 0;
}
